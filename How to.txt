Generating Audio Wave Vector Graphics With Python

A client of mine wanted a clickable gadget on his wordpress homepage that could be used
to control and play a piece of music that he wanted to feature. Visually speaking he wanted
it to somewhat resemble to travel bar you see on websites such as SoundCloud, but
to fit quite neatly into his current existing homepage theme.

I generated an svg file based on the audio data of the music.

This was an easy but interesting project for me, I'll show you how I did it.

Begin by starting a new python project in a text editor of your choice and import the 
following modules.

import wave
import numpy as np
import drawsvg as draw

We will start by reading the audio data in the music file into an object of the wave library.

wav_obj = wave.open('Aragainz.wav', 'rb')
sample_freq = wav_obj.getframerate()
n_samples = wav_obj.getnframes()
signal_wave = wav_obj.readframes(n_samples)
signal_array = np.frombuffer(signal_wave, dtype=np.int16)

Without expanding too heavily on the details the sample_freq quantifies how many times per second
a track takes a "snap-shot" of a given sound wave, and n_samples quantifies the total number
of these "snap-shots" in the file. It stands to reason that if your sampling frequency is 44.1 kHz,
and your piece of music if 100 seconds long, then you will have about 4.41 million samples in your audio file.
From this we can derive the length of any track based on it's sampling frequency and number of samples

length =  n_samples / sample_freq

with units n / s^-1 = ns (time), where n is an integer

signal_wave is a bytes array that expresses every slice of audio data in the track as an 8-bit hex number, this is then passed
to a numpy array of 16 bit integers, which incidently halves the length of the array.

Next, we split the audio channels into left and right respectively, using a numpy operation:

l_channel = signal_array[0::2]

Because accuracy is NOT important here, for the remainder of this demo we will only be using the left channel.

We intend to take the l_channel array and derive a kind of "average value" for every 60th part of the array. 
These average values will be used to quanitify the height of the rectangular bars that will characterise our
final svg graphic.

Let's define the number of sample elements that will go into a sample bin:

sample_bin_size = len(l_channel)//60

A some other variables required for the iteration we will perform:

result = []
n = 0
sample_bin = 0

With elementary python syntax the iteration is as follows:

for i in l_channel:
    if n < sample_bin_size:
        sample_bin += abs(l_channel[i]) 
        n += 1
    else:
        n = 0
        result.append(sample_bin/sample_bin_size)
        sample_bin = 0

It is worth noting that we use the absolute value l_channel[i], this is because sound waves are oscillatory
and by definition must have regions that occupy a negative number space. For more information study fourier series...

We then define a normalisation factor and use it to ensure every value in the result is defined relative to 80,
in my intended graphic the dimensions will be 300 x 80, therefore no y value should exceed 80.

normalisation_factor = 80/max(result)
normed_result = [i*normalisation_factor for i in result]

We now have a complete set of values characterised by the "average loudness" of the song at their point on a
horizontal line.

Using the drawsvg library we begin any new svg file by defining it's most basic parameters - the x, y dimensions
and a point of origin for the coordinate system thereof.

d = draw.Drawing(300, 80, origin=(0,0))

Within this drawing we can draw a rectangle using the draw.Rectangle method, it has the following form:

draw.Rectangle(float x, float y, int width, int height, fill='#hexnumber')

It's worth noting that the "direction" of the rectangle drawing is always in the positive x and positive y directions of the coordinate space.

Using elementary python syntax I then iteratively drew a kind of bar chart representing the average loudness:

width = 5
gap = 0
x = 0
max_height = 80

for i in normed_result:
    val = round(i)
    d.append(
         draw.Rectangle(x, (max_height - val)/2, width, val, fill='#245b5a')

    )
    d2.append(
         draw.Rectangle(x, (max_height - val)/2, width, val, fill='#FF0078')

    )

    x += width + gap

Here I draw two different images and save them to two different files.

d.save_svg('wave-grey3.svg')
d2.save_svg('wave-pink3.svg')

There's obviously much scope for experimentation here, as well as improvement. This is not an accurate 
"average loudness" spectrum, but it could be with refinement. However, as a kind of cartoon 
representation of the audio file it works perfectly.

Next-up: turning these images into an audio controller within a web browser.